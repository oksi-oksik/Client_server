# Client_server

## Тестовое задание ДПО КС взаимодействие (С++, Qt, Python)

Разработать клиент и сервер, которые будут взаимодействовать по описанному ниже протоколу. Клиент и сервер должны быть разработаны с использованием асинхронного подхода – все функции сетевого взаимодействия должны быть асинхронные, оба приложения должны быть однопоточные (разработанный код не должен явно порождать дочерние потоки исполнения).


### Протокол

##### syntax = "proto2";

##### package TestTask.Messages;

##### message WrapperMessage {

##### optional FastResponse fast_response = 1;

##### optional SlowResponse slow_response = 2;

##### optional RequestForFastResponse request_for_fast_response = 3;

##### optional RequestForSlowResponse request_for_slow_response = 4;

##### }

##### message FastResponse {

##### required string current_date_time = 1;

##### }

##### message SlowResponse {

##### required uint32 connected_client_count = 1;

##### }

##### message RequestForFastResponse {

##### }

##### message RequestForSlowResponse {

##### required uint32 time_in_seconds_to_sleep = 1;

##### }


### Особенности передачи сообщений по Protobuf/TCP

* Каждое сообщение будет предварять его размер (length-prefixed). Для размера должен быть использован тип Varint32. https://developers.google.com/protocol-buffers/docs/techniques#streaming

* Передаваться всегда будет  WrapperMessage(заполнено только одно из опциональных полей – только так можно понять при разборе какое именно сообщение нам пришло)

* Время должно быть в ISO формате: YYYYMMDDThhmmss.fff например: 19851019T050107.333 - 19 октября 1985 года 5 часов 1 минута 7секунд 333 миллисекунды. Кодировка строк – UTF8.

* Следует обратить внимание, что TCP – потоковый протокол, поэтому при приеме сообщений необходимо учесть, что в общем случае может прийти любая часть сообщения, несколько сообщений сразу – в общем любой кусок от переданного потока (нельзя даже рассчитывать, что предваряющий размер сообщения придет полностью). Поэтому необходимо при приеме обязательно использовать буфер

### Описание требований к клиенту

Клиент должен уметь:

* посылать по запросу пользователя  выбранный запрос  серверу (RequestForFastResponse или RequestForSlowResponse)
* посылать  выбранный запрос серверу с указанным пользователем таймаутом (от 10 до 1000 мс)
* вести лог отправленных запросов/принятых ответов, подключений к серверу, потерь соединения  с сервером(лог отображать на графическом интерфейсе)
* при потере соединения с сервером (или неуспешном подключении) автоматически выполнять подключение по прошествии указанного пользователем таймаута (1 – 10 секунд)
* позволять пользователю вводить ip-адрес и порт сервера
* позволять пользователю вводить время, которое сервер должен спать при обработке  RequestForSlowResponse

#### Технические требования:

* клиент должен быть написан на Python с графическим интерфейсом на PyQt5(https://pypi.org/project/PyQt5/)
* для сетевого обмена использовать PyQt5
* клиент не должен посылать следующий запрос, если не получил ответ на предыдущий – например, если выбран режим отправки по таймауту – то при наступлении таймаута клиент должен проверить, а получил ли он ответ на предыдущий запрос


### Описание требований к серверу

Сервер должен уметь:

* считывать из конфигурационного файла порт, который слушать
* отвечать на  RequestForFastResponse сообщением  FastResponse с текущем временем на машине сервера
* отвечать на  RequestForSlowResponse следующим образом: при приеме запроса фиксировать текущее количество подключенных клиентов, асинхронно спать указанное в запросе количество секунд, отправлять ответ клиенту по истечении этого таймаута (тут важно, что сервер должен спать именно асинхронно – пока он “заснул” для одного клиента, запросы от других он должен обрабатывать)
* вести лог покдключений/отключений клиентов(лог писать в файл)


#### Технические требования к серверу:

* сервер должен быть реализован на Python и на C++
* На C++ – boost::asio(https://www.boost.org/doc/libs/1_80_0/doc/html/boost_asio/example/cpp11/echo/async_tcp_echo_server.cpp)
* На питоне – Twisted(https://docs.twisted.org/en/stable/core/examples/index.html)


### Общие требования

* На код разбора сообщения должны быть написаны модульные тесты (как на C++, так и на python)
* C++ - Google Test, python – unittest
* Естественно код разбора сообщения (и другие общие части, если будут) должен быть выделен в common и не дублироваться в каждом варианте сервера и в клиенте (для C++ и питона они будут дублироваться – писать какие-нибудь биндинги в данной задаче не нужно)
